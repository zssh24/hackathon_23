"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
const apache_arrow_1 = require("apache-arrow");
const utils_1 = require("./utils");
const { isArrowBigNumSymbol, bigNumToBigInt } = apache_arrow_1.util;
class ArrowResult {
    constructor(context, schema, arrowSchema) {
        this.context = context;
        this.schema = (0, utils_1.getSchemaColumns)(schema);
        this.arrowSchema = arrowSchema;
    }
    hasPendingData() {
        return __awaiter(this, void 0, void 0, function* () {
            return false;
        });
    }
    getValue(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.schema.length === 0 || !this.arrowSchema || !data) {
                return [];
            }
            const batches = yield this.getBatches(data);
            if (batches.length === 0) {
                return [];
            }
            const table = (0, apache_arrow_1.tableFromIPC)([this.arrowSchema, ...batches]);
            return this.getRows(table.schema, table.toArray());
        });
    }
    getBatches(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            data.forEach((rowSet) => {
                var _a;
                (_a = rowSet.arrowBatches) === null || _a === void 0 ? void 0 : _a.forEach((arrowBatch) => {
                    if (arrowBatch.batch) {
                        result.push(arrowBatch.batch);
                    }
                });
            });
            return result;
        });
    }
    getRows(schema, rows) {
        return rows.map((row) => {
            // First, convert native Arrow values to corresponding plain JS objects
            const record = this.convertArrowTypes(row, undefined, schema.fields);
            // Second, cast all the values to original Thrift types
            return this.convertThriftTypes(record);
        });
    }
    convertArrowTypes(value, valueType, fields = []) {
        var _a;
        if (value === null) {
            return value;
        }
        const fieldsMap = {};
        for (const field of fields) {
            fieldsMap[field.name] = field;
        }
        // Convert structures to plain JS object and process all its fields recursively
        if (value instanceof apache_arrow_1.StructRow) {
            const result = value.toJSON();
            for (const key of Object.keys(result)) {
                const field = fieldsMap[key];
                result[key] = this.convertArrowTypes(result[key], field === null || field === void 0 ? void 0 : field.type, (field === null || field === void 0 ? void 0 : field.type.children) || []);
            }
            return result;
        }
        if (value instanceof apache_arrow_1.MapRow) {
            const result = value.toJSON();
            // Map type consists of its key and value types. We need only value type here, key will be cast to string anyway
            const field = (_a = fieldsMap.entries) === null || _a === void 0 ? void 0 : _a.type.children.find((item) => item.name === 'value');
            for (const key of Object.keys(result)) {
                result[key] = this.convertArrowTypes(result[key], field === null || field === void 0 ? void 0 : field.type, (field === null || field === void 0 ? void 0 : field.type.children) || []);
            }
            return result;
        }
        // Convert lists to JS array and process items recursively
        if (value instanceof apache_arrow_1.Vector) {
            const result = value.toJSON();
            // Array type contains the only child which defines a type of each array's element
            const field = fieldsMap.element;
            return result.map((item) => this.convertArrowTypes(item, field === null || field === void 0 ? void 0 : field.type, (field === null || field === void 0 ? void 0 : field.type.children) || []));
        }
        if (apache_arrow_1.DataType.isTimestamp(valueType)) {
            return new Date(value);
        }
        // Convert big number values to BigInt
        // Decimals are also represented as big numbers in Arrow, so additionally process them (convert to float)
        if (value instanceof Object && value[isArrowBigNumSymbol]) {
            const result = bigNumToBigInt(value);
            if (apache_arrow_1.DataType.isDecimal(valueType)) {
                return Number(result) / Math.pow(10, valueType.scale);
            }
            return result;
        }
        // Convert binary data to Buffer
        if (value instanceof Uint8Array) {
            return buffer_1.Buffer.from(value);
        }
        // Return other values as is
        return typeof value === 'bigint' ? Number(value) : value;
    }
    convertThriftTypes(record) {
        const result = {};
        this.schema.forEach((column) => {
            var _a;
            const typeDescriptor = (_a = column.typeDesc.types[0]) === null || _a === void 0 ? void 0 : _a.primitiveEntry;
            const field = column.columnName;
            const value = record[field];
            result[field] = value === null ? null : (0, utils_1.convertThriftValue)(typeDescriptor, value);
        });
        return result;
    }
}
exports.default = ArrowResult;
//# sourceMappingURL=ArrowResult.js.map