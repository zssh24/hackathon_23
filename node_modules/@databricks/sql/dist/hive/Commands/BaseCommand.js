"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const thrift_1 = require("thrift");
const HiveDriverError_1 = __importDefault(require("../../errors/HiveDriverError"));
const globalConfig_1 = __importDefault(require("../../globalConfig"));
function getRetryDelay(attempt) {
    const scale = Math.max(1, Math.pow(1.5, (attempt - 1))); // ensure scale >= 1
    return Math.min(globalConfig_1.default.retryDelayMin * scale, globalConfig_1.default.retryDelayMax);
}
function delay(milliseconds) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), milliseconds);
    });
}
class BaseCommand {
    constructor(client) {
        this.client = client;
    }
    executeCommand(request, command) {
        return this.invokeWithErrorHandling(request, command, { startTime: Date.now(), attempt: 0 });
    }
    invokeWithErrorHandling(request, command, info) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.invokeCommand(request, command);
            }
            catch (error) {
                if (error instanceof thrift_1.Thrift.TApplicationException) {
                    if ('statusCode' in error) {
                        switch (error.statusCode) {
                            // On these status codes it's safe to retry the request. However,
                            // both error codes mean that server is overwhelmed or even down.
                            // Therefore, we need to add some delay between attempts so
                            // server can recover and more likely handle next request
                            case 429: // Too Many Requests
                            case 503: // Service Unavailable
                                info.attempt += 1;
                                // Delay interval depends on current attempt - the more attempts we do
                                // the longer the interval will be
                                // TODO: Respect `Retry-After` header (PECO-729)
                                const retryDelay = getRetryDelay(info.attempt);
                                const attemptsExceeded = info.attempt >= globalConfig_1.default.retryMaxAttempts;
                                if (attemptsExceeded) {
                                    throw new HiveDriverError_1.default(`Hive driver: ${error.statusCode} when connecting to resource. Max retry count exceeded.`);
                                }
                                const timeoutExceeded = Date.now() - info.startTime + retryDelay >= globalConfig_1.default.retriesTimeout;
                                if (timeoutExceeded) {
                                    throw new HiveDriverError_1.default(`Hive driver: ${error.statusCode} when connecting to resource. Retry timeout exceeded.`);
                                }
                                yield delay(retryDelay);
                                return this.invokeWithErrorHandling(request, command, info);
                            // TODO: Here we should handle other error types (see PECO-730)
                            // no default
                        }
                    }
                }
                // Re-throw error we didn't handle
                throw error;
            }
        });
    }
    invokeCommand(request, command) {
        if (typeof command !== 'function') {
            return Promise.reject(new HiveDriverError_1.default('Hive driver: the operation does not exist, try to choose another Thrift file.'));
        }
        return new Promise((resolve, reject) => {
            try {
                command.call(this.client, request, (err, response) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(response);
                    }
                });
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
exports.default = BaseCommand;
//# sourceMappingURL=BaseCommand.js.map